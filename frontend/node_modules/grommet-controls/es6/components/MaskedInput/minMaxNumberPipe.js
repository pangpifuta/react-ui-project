var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

import { transformMaskedValue } from './utils';

export var maskedNumberValue = function maskedNumberValue(_ref) {
  var value = _ref.value,
      prefix = _ref.prefix,
      suffix = _ref.suffix,
      thousandsSeparatorSymbol = _ref.thousandsSeparatorSymbol;

  var val = value;
  if (typeof val === 'string') {
    val = val.replace(new RegExp('[' + prefix + suffix + thousandsSeparatorSymbol + ']', 'g'), '');
    val = parseFloat(val);
    if (Number.isNaN(val)) {
      val = undefined;
    }
  }
  return val;
};

var createMinMaxInputPipe = function createMinMaxInputPipe(_ref2) {
  var min = _ref2.min,
      max = _ref2.max,
      mask = _ref2.mask,
      props = _objectWithoutProperties(_ref2, ['min', 'max', 'mask']);

  return function (conformedValue) {
    if (typeof min === 'number' || typeof max === 'number') {
      var value = maskedNumberValue(_extends({}, props, { value: conformedValue }));
      if (typeof value === 'number') {
        if (typeof min === 'number' && value < min) {
          var resolved = transformMaskedValue(min, mask, props);
          if (resolved === undefined) {
            return false;
          }
          return { value: resolved };
        }
        if (typeof max === 'number' && value > max) {
          var _resolved = transformMaskedValue(max, mask, props);
          if (_resolved === undefined) {
            return false;
          }
          return { value: _resolved };
        }
      }
    }
    return { value: conformedValue };
  };
};
export { createMinMaxInputPipe };