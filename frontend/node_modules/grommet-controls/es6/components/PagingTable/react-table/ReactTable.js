var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-nested-ternary,no-shadow,no-param-reassign,
prefer-destructuring,no-mixed-operators */
import React, { Component } from 'react';
import _ from './utils';
import defaultProps from './defaultProps';
import { focusNextElement, focusPrevElement } from '../DOM';

var ReactTable = function (_Component) {
  _inherits(ReactTable, _Component);

  function ReactTable(props) {
    _classCallCheck(this, ReactTable);

    var _this = _possibleConstructorReturn(this, _Component.call(this));

    _initialiseProps.call(_this);

    _this.rowRef = [];
    _this.state = {
      page: 0,
      pageSize: props.defaultPageSize,
      sorted: props.defaultSorted,
      expanded: props.defaultExpanded,
      filtered: props.defaultFiltered,
      resized: props.defaultResized,
      currentlyResizing: false,
      skipNextSort: false
    };
    return _this;
  }

  ReactTable.prototype.componentWillMount = function componentWillMount() {
    this.setStateWithData(this.getDataModel(this.getResolvedState()));
  };

  ReactTable.prototype.componentDidMount = function componentDidMount() {
    this.fireFetchData();
  };

  ReactTable.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextState) {
    var oldState = this.getResolvedState();
    var newState = this.getResolvedState(nextProps, nextState);

    // Do a deep compare of new and old `defaultOption` and
    // if they are different reset `option = defaultOption`
    var defaultableOptions = ['sorted', 'filtered', 'resized', 'expanded'];
    defaultableOptions.forEach(function (x) {
      var defaultName = 'default' + (x.charAt(0).toUpperCase() + x.slice(1));
      if (JSON.stringify(oldState[defaultName]) !== JSON.stringify(newState[defaultName])) {
        newState[x] = newState[defaultName];
      }
    });

    // If they change these table options, we need to reset defaults
    // or else we could get into a state where the user has changed the UI
    // and then disabled the ability to change it back.
    // e.g. If `filterable` has changed, set `filtered = defaultFiltered`
    var resettableOptions = ['sortable', 'filterable', 'resizable'];
    resettableOptions.forEach(function (x) {
      if (oldState[x] !== newState[x]) {
        var baseName = x.replace('able', '');
        var optionName = baseName + 'ed';
        var defaultName = 'default' + (optionName.charAt(0).toUpperCase() + optionName.slice(1));
        newState[optionName] = newState[defaultName];
      }
    });

    // Props that trigger a data update
    if (oldState.data !== newState.data || JSON.stringify(oldState.columns) !== JSON.stringify(newState.columns) || oldState.pivotBy !== newState.pivotBy || oldState.sorted !== newState.sorted || oldState.filtered !== newState.filtered) {
      this.setStateWithData(this.getDataModel(newState));
    }
  };

  ReactTable.prototype.setStateWithData = function setStateWithData(newState, cb) {
    var _this2 = this;

    var oldState = this.getResolvedState();
    var newResolvedState = this.getResolvedState({}, newState);
    var freezeWhenExpanded = newResolvedState.freezeWhenExpanded;

    // Default to unfrozen state

    newResolvedState.frozen = false;

    // If freezeWhenExpanded is set, check for frozen conditions
    if (freezeWhenExpanded) {
      // if any rows are expanded, freeze the existing data and sorting
      var keys = Object.keys(newResolvedState.expanded);
      for (var i = 0; i < keys.length; i += 1) {
        if (newResolvedState.expanded[keys[i]]) {
          newResolvedState.frozen = true;
          break;
        }
      }
    }

    // If the data isn't frozen and either the data or
    // sorting model has changed, update the data
    if (oldState.frozen && !newResolvedState.frozen || oldState.sorted !== newResolvedState.sorted || oldState.filtered !== newResolvedState.filtered || oldState.showFilters !== newResolvedState.showFilters || !newResolvedState.frozen && oldState.resolvedData !== newResolvedState.resolvedData) {
      // Handle collapseOnsortedChange & collapseOnDataChange
      if (oldState.sorted !== newResolvedState.sorted && this.props.collapseOnSortingChange || oldState.filtered !== newResolvedState.filtered || oldState.showFilters !== newResolvedState.showFilters || oldState.sortedData && !newResolvedState.frozen && oldState.resolvedData !== newResolvedState.resolvedData && this.props.collapseOnDataChange) {
        newResolvedState.expanded = {};
      }

      Object.assign(newResolvedState, this.getSortedData(newResolvedState));
    }

    // Set page to 0 if filters change
    if (oldState.filtered !== newResolvedState.filtered) {
      newResolvedState.page = 0;
    }

    // Calculate pageSize all the time
    if (newResolvedState.sortedData) {
      newResolvedState.pages = newResolvedState.manual ? newResolvedState.pages : Math.ceil(newResolvedState.sortedData.length / newResolvedState.pageSize);
      newResolvedState.page = Math.max(newResolvedState.page >= newResolvedState.pages ? newResolvedState.pages - 1 : newResolvedState.page, 0);
    }

    return this.setState(newResolvedState, function () {
      if (cb) {
        cb();
      }
      if (oldState.page !== newResolvedState.page || oldState.pageSize !== newResolvedState.pageSize || oldState.sorted !== newResolvedState.sorted || oldState.filtered !== newResolvedState.filtered) {
        _this2.fireFetchData();
      }
    });
  };

  // User actions


  ReactTable.prototype.render = function render() {
    var _this3 = this;

    var resolvedState = this.getResolvedState();
    var children = resolvedState.children,
        getProps = resolvedState.getProps,
        getTableProps = resolvedState.getTableProps,
        getTheadGroupProps = resolvedState.getTheadGroupProps,
        getTheadGroupTrProps = resolvedState.getTheadGroupTrProps,
        getTheadProps = resolvedState.getTheadProps,
        getTheadTrProps = resolvedState.getTheadTrProps,
        getTheadThProps = resolvedState.getTheadThProps,
        getTheadFilterProps = resolvedState.getTheadFilterProps,
        getTheadFilterTrProps = resolvedState.getTheadFilterTrProps,
        getTheadFilterThProps = resolvedState.getTheadFilterThProps,
        getFilterInputProps = resolvedState.getFilterInputProps,
        getTbodyProps = resolvedState.getTbodyProps,
        getTrGroupProps = resolvedState.getTrGroupProps,
        getTrProps = resolvedState.getTrProps,
        getTdProps = resolvedState.getTdProps,
        getExpanderProps = resolvedState.getExpanderProps,
        getTfootProps = resolvedState.getTfootProps,
        getTfootTrProps = resolvedState.getTfootTrProps,
        getTfootTdProps = resolvedState.getTfootTdProps,
        getPaginationProps = resolvedState.getPaginationProps,
        getLoadingProps = resolvedState.getLoadingProps,
        getNoDataProps = resolvedState.getNoDataProps,
        getResizerProps = resolvedState.getResizerProps,
        showPagination = resolvedState.showPagination,
        showPaginationTop = resolvedState.showPaginationTop,
        showPaginationBottom = resolvedState.showPaginationBottom,
        manual = resolvedState.manual,
        loadingText = resolvedState.loadingText,
        noDataText = resolvedState.noDataText,
        sortable = resolvedState.sortable,
        multiSort = resolvedState.multiSort,
        resizable = resolvedState.resizable,
        filterable = resolvedState.filterable,
        pivotIDKey = resolvedState.pivotIDKey,
        pivotValKey = resolvedState.pivotValKey,
        pivotBy = resolvedState.pivotBy,
        subRowsKey = resolvedState.subRowsKey,
        aggregatedKey = resolvedState.aggregatedKey,
        originalKey = resolvedState.originalKey,
        indexKey = resolvedState.indexKey,
        groupedByPivotKey = resolvedState.groupedByPivotKey,
        expanderTdDefaultProps = resolvedState.expanderTdDefaultProps,
        loading = resolvedState.loading,
        pageSize = resolvedState.pageSize,
        page = resolvedState.page,
        sorted = resolvedState.sorted,
        filtered = resolvedState.filtered,
        resized = resolvedState.resized,
        expanded = resolvedState.expanded,
        pages = resolvedState.pages,
        onExpandedChange = resolvedState.onExpandedChange,
        TableComponent = resolvedState.TableComponent,
        TheadComponent = resolvedState.TheadComponent,
        TbodyComponent = resolvedState.TbodyComponent,
        TrGroupComponent = resolvedState.TrGroupComponent,
        TrComponent = resolvedState.TrComponent,
        ThComponent = resolvedState.ThComponent,
        TdComponent = resolvedState.TdComponent,
        CellTextComponent = resolvedState.CellTextComponent,
        TfootComponent = resolvedState.TfootComponent,
        PaginationComponent = resolvedState.PaginationComponent,
        LoadingComponent = resolvedState.LoadingComponent,
        SubComponent = resolvedState.SubComponent,
        NoDataComponent = resolvedState.NoDataComponent,
        ResizerComponent = resolvedState.ResizerComponent,
        ExpanderComponent = resolvedState.ExpanderComponent,
        PivotValueComponent = resolvedState.PivotValueComponent,
        PivotComponent = resolvedState.PivotComponent,
        AggregatedComponent = resolvedState.AggregatedComponent,
        FilterComponent = resolvedState.FilterComponent,
        PadRowComponent = resolvedState.PadRowComponent,
        resolvedData = resolvedState.resolvedData,
        allVisibleColumns = resolvedState.allVisibleColumns,
        headerGroups = resolvedState.headerGroups,
        hasHeaderGroups = resolvedState.hasHeaderGroups,
        sortedData = resolvedState.sortedData;

    // Pagination

    var startRow = pageSize * page;
    var endRow = startRow + pageSize;
    var pageRows = manual ? resolvedData : sortedData.slice(startRow, endRow);
    var minRows = this.getMinRows();
    var padRows = _.range(Math.max(minRows - pageRows.length, 0));

    var hasColumnFooter = allVisibleColumns.some(function (d) {
      return d.Footer;
    });
    var hasFilters = filterable || allVisibleColumns.some(function (d) {
      return d.filterable;
    });

    var recurseRowsViewIndex = function recurseRowsViewIndex(rows) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      return [rows.map(function (row, i) {
        index += 1;
        var rowWithViewIndex = _extends({}, row, {
          viewIndex: index
        });
        var newPath = path.concat([i]);
        if (rowWithViewIndex[subRowsKey] && _.get(expanded, newPath)) {
          var _recurseRowsViewIndex = recurseRowsViewIndex(rowWithViewIndex[subRowsKey], newPath, index);

          rowWithViewIndex[subRowsKey] = _recurseRowsViewIndex[0];
          index = _recurseRowsViewIndex[1];
        }
        return rowWithViewIndex;
      }), index];
    };

    var _recurseRowsViewIndex2 = recurseRowsViewIndex(pageRows);

    pageRows = _recurseRowsViewIndex2[0];


    var canPrevious = page > 0;
    var canNext = page + 1 < pages;

    var rowMinWidth = _.sum(allVisibleColumns.map(function (d) {
      var resizedColumn = resized.find(function (x) {
        return x.id === d.id;
      }) || {};
      return _.getFirstDefined(resizedColumn.value, d.width, d.minWidth);
    }));

    var rowIndex = -1;

    var finalState = _extends({}, resolvedState, {
      startRow: startRow,
      endRow: endRow,
      pageRows: pageRows,
      minRows: minRows,
      padRows: padRows,
      hasColumnFooter: hasColumnFooter,
      canPrevious: canPrevious,
      canNext: canNext,
      rowMinWidth: rowMinWidth
    });

    var rootProps = getProps(finalState, undefined, undefined, this);
    var tableProps = getTableProps(finalState, undefined, undefined, this);
    var tBodyProps = getTbodyProps(finalState, undefined, undefined, this);
    var loadingProps = getLoadingProps(finalState, undefined, undefined, this);
    var noDataProps = getNoDataProps(finalState, undefined, undefined, this);

    // Visual Components

    var makeHeaderGroup = function makeHeaderGroup(column, i) {
      var resizedValue = function resizedValue(col) {
        return (resized.find(function (x) {
          return x.id === col.id;
        }) || {}).value;
      };
      var flex = _.sum(column.columns.map(function (col) {
        return col.width || resizedValue(col) ? 0 : col.minWidth;
      }));
      var width = _.sum(column.columns.map(function (col) {
        return _.getFirstDefined(resizedValue(col), col.width, col.minWidth);
      }));
      var maxWidth = _.sum(column.columns.map(function (col) {
        return _.getFirstDefined(resizedValue(col), col.width, col.maxWidth);
      }));

      var theadGroupThProps = getTheadGroupProps(finalState, undefined, column, _this3);
      var columnHeaderProps = column.getHeaderProps(finalState, undefined, column, _this3);

      var rest = _extends({}, theadGroupThProps, columnHeaderProps, {
        CellTextComponent: CellTextComponent
      });
      var flexStyles = {
        flex: flex + ' 0 auto',
        width: _.asPx(width),
        maxWidth: _.asPx(maxWidth)
      };

      return React.createElement(
        ThComponent,
        _extends({
          key: i + '-' + column.id,
          style: flexStyles
        }, rest),
        _.normalizeComponent(column.Header, {
          data: sortedData,
          column: column
        })
      );
    };
    var selectRow = function selectRow(index) {
      return function (nextRow, childIndex) {
        var selectFirstAvailable = function selectFirstAvailable(rows) {
          for (var i = 0; i < rows.length; i += 1) {
            if (rows[i]) {
              return rows[i].selectFirstChild(childIndex);
            }
          }
          return false;
        };
        var found = void 0;
        if (typeof index === 'number') {
          var _state = _this3.state,
              _page = _state.page,
              _pages = _state.pages;

          if (nextRow) {
            if (pageRows.length > index + 1) {
              found = _this3.rowRef[index + 1].selectFirstChild(childIndex);
            } else if (_page < _pages - 1) {
              _this3.onPageChange(_page + 1);
              found = true;
            } else {
              found = selectFirstAvailable([_this3.footerRef]);
            }
          } else if (index > 0) {
            found = _this3.rowRef[index - 1].selectFirstChild(childIndex);
          } else if (_page > 0) {
            _this3.onPageChange(_page - 1);
            found = true;
          } else {
            found = selectFirstAvailable([_this3.filterRef, _this3.headerRef, _this3.headerGroupsRef]);
          }
        }
        if (!found) {
          if (nextRow) {
            focusNextElement(document);
          } else {
            focusPrevElement(document);
          }
        }
      };
    };
    var makeHeaderGroups = function makeHeaderGroups() {
      var theadGroupProps = getTheadGroupProps(finalState, undefined, undefined, _this3);
      var theadGroupTrProps = getTheadGroupTrProps(finalState, undefined, undefined, _this3);
      return React.createElement(
        TheadComponent,
        _extends({
          style: { minWidth: rowMinWidth + 'px' }
        }, theadGroupProps),
        React.createElement(
          TrComponent,
          _extends({
            ref: function ref(el) {
              _this3.headerGroupsRef = el;
            },
            selectRow: selectRow('headerGroup')
          }, theadGroupTrProps),
          headerGroups.map(makeHeaderGroup)
        )
      );
    };

    var makeHeader = function makeHeader(column, i) {
      var resizedCol = resized.find(function (x) {
        return x.id === column.id;
      }) || {};
      var sort = sorted.find(function (d) {
        return d.id === column.id;
      });
      var show = typeof column.show === 'function' ? column.show() : column.show;
      var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
      var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
      var theadThProps = getTheadThProps(finalState, undefined, column, _this3);
      var columnHeaderProps = column.getHeaderProps(finalState, undefined, column, _this3);

      var rest = _extends({}, theadThProps, columnHeaderProps, {
        CellTextComponent: CellTextComponent
      });

      var isResizable = _.getFirstDefined(column.resizable, resizable, false);
      var resizer = isResizable ? React.createElement(ResizerComponent, _extends({
        onMouseDown: function onMouseDown(e) {
          return _this3.resizeColumnStart(e, column, false);
        },
        onTouchStart: function onTouchStart(e) {
          return _this3.resizeColumnStart(e, column, true);
        }
      }, getResizerProps('finalState', undefined, column, _this3))) : null;

      var isSortable = _.getFirstDefined(column.sortable, sortable, false);

      return React.createElement(
        ThComponent,
        _extends({
          key: i + '-' + column.id,
          sort: sort && (sort.desc ? '-sort-desc' : '-sort-asc'),
          resizable: isResizable,
          sortable: isSortable,
          hidden: !show,
          expander: column.expander,
          pivot: pivotBy && pivotBy.slice(0, -1).includes(column.id),

          style: {
            flex: width + ' 0 auto',
            width: _.asPx(width),
            maxWidth: _.asPx(maxWidth)
          },
          toggleSort: function toggleSort(e) {
            if (isSortable) _this3.sortColumn(column, multiSort ? e.shiftKey : false);
          }
        }, rest),
        _.normalizeComponent(column.Header, {
          data: sortedData,
          column: column
        }),
        resizer
      );
    };

    var makeHeaders = function makeHeaders() {
      var theadProps = getTheadProps(finalState, undefined, undefined, _this3);
      var theadTrProps = getTheadTrProps(finalState, undefined, undefined, _this3);
      return React.createElement(
        TheadComponent,
        _extends({
          header: true,
          style: {
            minWidth: rowMinWidth + 'px'
          }
        }, theadProps),
        React.createElement(
          TrComponent,
          _extends({
            ref: function ref(el) {
              _this3.headerRef = el;
            },
            selectRow: selectRow('header')
          }, theadTrProps),
          allVisibleColumns.map(makeHeader)
        )
      );
    };

    var makeFilter = function makeFilter(column, i) {
      var resizedCol = resized.find(function (x) {
        return x.id === column.id;
      }) || {};
      var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
      var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
      var theadFilterThProps = getTheadFilterThProps(finalState, undefined, column, _this3);
      var filterInputProps = getFilterInputProps(finalState, undefined, column, _this3);
      var columnHeaderProps = column.getFilterProps(finalState, undefined, column, _this3);

      var rest = _extends({}, theadFilterThProps, columnHeaderProps, {
        CellTextComponent: CellTextComponent
      });

      var filter = filtered.find(function (filter) {
        return filter.id === column.id;
      });

      var ResolvedFilterComponent = column.Filter || FilterComponent;

      var isFilterable = _.getFirstDefined(column.filterable, filterable, false);

      return React.createElement(
        ThComponent,
        _extends({
          key: i + '-' + column.id,
          style: {
            flex: width + ' 0 auto',
            width: _.asPx(width),
            maxWidth: _.asPx(maxWidth)
          }
        }, rest),
        isFilterable ? _.normalizeComponent(ResolvedFilterComponent, _extends({}, filterInputProps, {
          column: column,
          filter: filter,
          onChange: function onChange(value) {
            return _this3.filterColumn(column, value);
          }

        }), undefined) : null
      );
    };

    var makeFilters = function makeFilters() {
      var theadFilterProps = getTheadFilterProps(finalState, undefined, undefined, _this3);
      var theadFilterTrProps = getTheadFilterTrProps(finalState, undefined, undefined, _this3);
      return React.createElement(
        TheadComponent,
        _extends({
          filters: true,
          style: {
            minWidth: rowMinWidth + 'px'
          }
        }, theadFilterProps),
        React.createElement(
          TrComponent,
          _extends({
            ref: function ref(el) {
              _this3.filterRef = el;
            },
            selectRow: selectRow('filter')
          }, theadFilterTrProps),
          allVisibleColumns.map(makeFilter)
        )
      );
    };

    var makePageRow = function makePageRow(row, i) {
      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      var rowInfo = {
        original: row[originalKey],
        row: row,
        index: row[indexKey],
        viewIndex: rowIndex += 1,
        pageSize: pageSize,
        page: page,
        level: path.length,
        nestingPath: path.concat([i]),
        aggregated: row[aggregatedKey],
        groupedByPivot: row[groupedByPivotKey],
        subRows: row[subRowsKey]
      };

      var isExpanded = _.get(expanded, rowInfo.nestingPath);
      var trGroupProps = getTrGroupProps(finalState, rowInfo, undefined, _this3);
      var expanderProps = getExpanderProps(finalState);
      var trProps = getTrProps(row.viewIndex % 2, finalState, rowInfo, undefined, _this3);
      return React.createElement(
        TrGroupComponent,
        _extends({ key: rowInfo.nestingPath.join('_') }, trGroupProps),
        React.createElement(
          TrComponent,
          _extends({
            selectRow: selectRow(i),
            ref: function ref(el) {
              _this3.rowRef[i] = el;
            },
            rowIndex: row.viewIndex
          }, trProps),
          allVisibleColumns.map(function (column, i2) {
            var defaultTdProps = {};
            var resizedCol = resized.find(function (x) {
              return x.id === column.id;
            }) || {};
            var show = typeof column.show === 'function' ? column.show() : column.show;
            var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            var tdProps = getTdProps(finalState, rowInfo, column, _this3);
            var columnProps = column.getProps(finalState, rowInfo, column, _this3);

            var cellInfo = _extends({}, rowInfo, {
              isExpanded: isExpanded,
              column: _extends({}, column),
              value: rowInfo.row[column.id],
              pivoted: column.pivoted,
              expander: column.expander,
              resized: resized,
              show: show,
              width: width,
              maxWidth: maxWidth,
              tdProps: tdProps,
              columnProps: columnProps
            });

            var value = cellInfo.value;

            var useOnExpanderClick = void 0;
            var isBranch = void 0;
            var isPreview = void 0;

            var onExpanderClick = function onExpanderClick(e) {
              var newExpanded = _.clone(expanded);
              if (isExpanded) {
                newExpanded = _.set(newExpanded, cellInfo.nestingPath, false);
              } else {
                newExpanded = _.set(newExpanded, cellInfo.nestingPath, {});
              }

              return _this3.setStateWithData({
                expanded: newExpanded
              }, function () {
                return onExpandedChange && onExpandedChange(newExpanded, cellInfo.nestingPath, e);
              });
            };

            // Default to a standard cell
            if (column.Cell) {
              value = _.normalizeComponent(column.Cell, cellInfo, value);
            }
            var cellProps = _extends({}, tdProps, columnProps);
            var resolvedCell = React.createElement(CellTextComponent, _extends({ value: value }, cellProps));

            // Resolve Renderers
            var ResolvedAggregatedComponent = column.Aggregated || (!column.aggregate ? AggregatedComponent : column.Cell);
            var ResolvedExpanderComponent = column.Expander || ExpanderComponent;
            var ResolvedPivotValueComponent = column.PivotValue || PivotValueComponent;
            var DefaultResolvedPivotComponent = PivotComponent || function (props) {
              return React.createElement(
                'div',
                null,
                React.createElement(ResolvedExpanderComponent, _extends({}, props, { expanderProps: expanderProps })),
                React.createElement(ResolvedPivotValueComponent, props)
              );
            };
            var ResolvedPivotComponent = column.Pivot || DefaultResolvedPivotComponent;

            // Is this cell expandable?
            if (cellInfo.pivoted || cellInfo.expander) {
              // Make it expandable by defualt
              cellInfo.expandable = true;
              useOnExpanderClick = true;
              // If pivoted, has no subRows, and does not have a subComponent,
              // do not make expandable
              if (cellInfo.pivoted && !cellInfo.subRows && !SubComponent) {
                cellInfo.expandable = false;
              }
            }

            if (cellInfo.pivoted) {
              // Is this column a branch?
              isBranch = rowInfo.row[pivotIDKey] === column.id && cellInfo.subRows;
              // Should this column be blank?
              isPreview = pivotBy.indexOf(column.id) > pivotBy.indexOf(rowInfo.row[pivotIDKey]) && cellInfo.subRows;
              // Pivot Cell Render Override
              if (isBranch) {
                // isPivot
                resolvedCell = _.normalizeComponent(ResolvedPivotComponent, _extends({}, cellInfo, {
                  value: row[pivotValKey]
                }), row[pivotValKey]);
              } else if (isPreview) {
                // Show the pivot preview
                resolvedCell = _.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
              } else {
                resolvedCell = null;
              }
            } else if (cellInfo.aggregated) {
              resolvedCell = _.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
            }

            if (cellInfo.expander) {
              defaultTdProps = expanderTdDefaultProps;
              resolvedCell = _.normalizeComponent(ResolvedExpanderComponent, _extends({}, cellInfo, { expanderProps: expanderProps }), row[pivotValKey]);
              if (pivotBy) {
                if (cellInfo.groupedByPivot) {
                  resolvedCell = null;
                }
                if (!cellInfo.subRows && !SubComponent) {
                  resolvedCell = null;
                }
              }
            }

            var resolvedOnExpanderClick = useOnExpanderClick ? onExpanderClick : function () {};

            // If there are multiple onClick events, make sure they don't
            // override eachother. This should maybe be expanded to handle all
            // function attributes
            var interactionProps = {
              onClick: resolvedOnExpanderClick
            };

            if (tdProps.onClick) {
              interactionProps.onClick = function (e) {
                tdProps.onClick(e, function () {
                  return resolvedOnExpanderClick(e);
                });
              };
            }

            if (columnProps.onClick) {
              interactionProps.onClick = function (e) {
                columnProps.onClick(e, function () {
                  return resolvedOnExpanderClick(e);
                });
              };
            }

            // Return the cell
            return React.createElement(
              TdComponent
              // eslint-disable-next-line react/no-array-index-key
              ,
              _extends({ key: i2 + '-' + column.id,
                hidden: !show,
                style: {
                  flex: width + ' 0 auto',
                  width: _.asPx(width),
                  maxWidth: _.asPx(maxWidth)
                }
              }, tdProps, columnProps, interactionProps, defaultTdProps),
              resolvedCell
            );
          })
        ),
        rowInfo.subRows && isExpanded && rowInfo.subRows.map(function (d, i) {
          return makePageRow(d, i, rowInfo.nestingPath);
        }),
        SubComponent && !rowInfo.subRows && isExpanded && SubComponent(rowInfo)
      );
    };

    var makePadColumn = function makePadColumn(column, i) {
      var resizedCol = resized.find(function (x) {
        return x.id === column.id;
      }) || {};
      var show = typeof column.show === 'function' ? column.show() : column.show;
      var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
      var flex = width;
      var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
      var tdProps = getTdProps(finalState, undefined, column, _this3);
      return React.createElement(
        TdComponent,
        _extends({
          key: i + '-' + column.id,
          hidden: !show,
          style: {
            flex: flex + ' 0 auto',
            width: _.asPx(width),
            maxWidth: _.asPx(maxWidth)
          }
        }, tdProps),
        _.normalizeComponent(PadRowComponent)
      );
    };

    var makePadRow = function makePadRow(row, i) {
      var trGroupProps = getTrGroupProps(finalState, undefined, undefined, _this3);
      var trProps = getTrProps(row.viewIndex % 2, finalState, undefined, undefined, _this3);
      return React.createElement(
        TrGroupComponent,
        _extends({ key: i }, trGroupProps),
        React.createElement(
          TrComponent,
          _extends({
            padrow: true,
            even: (pageRows.length + i) % 2
          }, trProps),
          allVisibleColumns.map(makePadColumn)
        )
      );
    };

    var makeColumnFooter = function makeColumnFooter(column, i) {
      var resizedCol = resized.find(function (x) {
        return x.id === column.id;
      }) || {};
      var show = typeof column.show === 'function' ? column.show() : column.show;
      var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
      var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
      var tFootTdProps = getTfootTdProps(finalState, undefined, undefined, _this3);
      var columnProps = column.getProps(finalState, undefined, column, _this3);
      var columnFooterProps = column.getFooterProps(finalState, undefined, column, _this3);

      return React.createElement(
        TdComponent,
        _extends({
          key: i + '-' + column.id,
          hidden: !show,
          style: {
            flex: width + ' 0 auto',
            width: _.asPx(width),
            maxWidth: _.asPx(maxWidth)
          }
        }, columnProps, tFootTdProps, columnFooterProps),
        _.normalizeComponent(column.Footer, {
          data: sortedData,
          column: column
        })
      );
    };

    var makeColumnFooters = function makeColumnFooters() {
      var tFootProps = getTfootProps(finalState, undefined, undefined, _this3);
      var tFootTrProps = getTfootTrProps(finalState, undefined, undefined, _this3);
      return React.createElement(
        TfootComponent,
        _extends({
          style: {
            minWidth: rowMinWidth + 'px'
          }
        }, tFootProps),
        React.createElement(
          TrComponent,
          _extends({
            ref: function ref(el) {
              _this3.footerRef = el;
            },
            selectRow: selectRow('footer')
          }, tFootTrProps),
          allVisibleColumns.map(makeColumnFooter)
        )
      );
    };

    var makePagination = function makePagination() {
      var paginationProps = getPaginationProps(finalState, undefined, undefined, _this3);
      return React.createElement(PaginationComponent, _extends({}, resolvedState, {
        pages: pages,
        canPrevious: canPrevious,
        canNext: canNext,
        onPageChange: _this3.onPageChange,
        onPageSizeChange: _this3.onPageSizeChange
      }, paginationProps));
    };

    var makeTable = function makeTable() {
      var pagination = makePagination();
      return React.createElement(
        'div',
        rootProps,
        showPagination && showPaginationTop ? React.createElement(
          'div',
          null,
          pagination
        ) : null,
        React.createElement(
          TableComponent,
          tableProps,
          hasHeaderGroups ? makeHeaderGroups() : null,
          makeHeaders(),
          hasFilters ? makeFilters() : null,
          React.createElement(
            TbodyComponent,
            _extends({
              style: {
                minWidth: rowMinWidth + 'px'
              }
            }, tBodyProps),
            React.createElement(LoadingComponent, _extends({
              loading: loading,
              loadingText: loadingText
            }, loadingProps)),
            pageRows.map(function (d, i) {
              return makePageRow(d, i);
            }),
            padRows.map(makePadRow)
          ),
          hasColumnFooter ? makeColumnFooters() : null
        ),
        showPagination && showPaginationBottom ? React.createElement(
          'div',
          null,
          pagination
        ) : null,
        !pageRows.length && !loading && React.createElement(
          NoDataComponent,
          noDataProps,
          _.normalizeComponent(noDataText)
        )
      );
    };

    // childProps are optionally passed to a function-as-a-child
    return children ? children(finalState, makeTable, this) : makeTable();
  };

  return ReactTable;
}(Component);

ReactTable.defaultProps = defaultProps;

var _initialiseProps = function _initialiseProps() {
  var _this4 = this;

  this.getResolvedState = function (props, state) {
    var resolvedState = _extends({}, _.compactObject(_this4.state), _.compactObject(_this4.props), _.compactObject(state), _.compactObject(props));
    return resolvedState;
  };

  this.getDataModel = function (newState) {
    var columns = newState.columns,
        _newState$pivotBy = newState.pivotBy,
        pivotBy = _newState$pivotBy === undefined ? [] : _newState$pivotBy,
        data = newState.data,
        pivotIDKey = newState.pivotIDKey,
        pivotValKey = newState.pivotValKey,
        subRowsKey = newState.subRowsKey,
        aggregatedKey = newState.aggregatedKey,
        nestingLevelKey = newState.nestingLevelKey,
        originalKey = newState.originalKey,
        indexKey = newState.indexKey,
        groupedByPivotKey = newState.groupedByPivotKey,
        SubComponent = newState.SubComponent;

    // Determine Header Groups

    var hasHeaderGroups = false;
    columns.forEach(function (column) {
      if (column.columns) {
        hasHeaderGroups = true;
      }
    });

    var columnsWithExpander = [].concat(columns);

    var expanderColumn = columns.find(function (col) {
      return col.expander || col.columns && col.columns.some(function (col2) {
        return col2.expander;
      });
    });
    // The actual expander might be in the columns field of a group column
    if (expanderColumn && !expanderColumn.expander) {
      expanderColumn = expanderColumn.columns.find(function (col) {
        return col.expander;
      });
    }

    // If we have SubComponent's we need to make sure we have an expander column
    if (SubComponent && !expanderColumn) {
      expanderColumn = { expander: true };
      columnsWithExpander = [expanderColumn].concat(columnsWithExpander);
    }

    var makeDecoratedColumn = function makeDecoratedColumn(column, parentColumn) {
      var dcol = void 0;
      if (column.expander) {
        dcol = _extends({}, _this4.props.column, _this4.props.expanderDefaults, column);
      } else {
        dcol = _extends({}, _this4.props.column, column);
      }

      // Ensure minWidth is not greater than maxWidth if set
      if (dcol.maxWidth < dcol.minWidth) {
        dcol.minWidth = dcol.maxWidth;
      }

      if (parentColumn) {
        dcol.parentColumn = parentColumn;
      }

      // First check for string accessor
      if (typeof dcol.accessor === 'string') {
        dcol.id = dcol.id || dcol.accessor;
        var accessorString = dcol.accessor;
        dcol.accessor = function (row) {
          return _.get(row, accessorString);
        };
        return dcol;
      }

      // Fall back to functional accessor (but require an ID)
      if (dcol.accessor && !dcol.id) {
        console.warn(dcol);
        throw new Error('A column id is required if using a non-string accessor for column above.');
      }

      // Fall back to an undefined accessor
      if (!dcol.accessor) {
        dcol.accessor = function () {
          return undefined;
        };
      }

      return dcol;
    };

    var allDecoratedColumns = [];

    // Decorate the columns
    var decorateAndAddToAll = function decorateAndAddToAll(column, parentColumn) {
      var decoratedColumn = makeDecoratedColumn(column, parentColumn);
      allDecoratedColumns.push(decoratedColumn);
      return decoratedColumn;
    };

    var decoratedColumns = columnsWithExpander.map(function (column) {
      if (column.columns) {
        return _extends({}, column, {
          columns: column.columns.map(function (d) {
            return decorateAndAddToAll(d, column);
          })
        });
      }
      return decorateAndAddToAll(column);
    });

    // Build the visible columns, headers and flat column list
    var visibleColumns = decoratedColumns.slice();
    var allVisibleColumns = [];

    visibleColumns = visibleColumns.map(function (column) {
      if (column.columns) {
        var visibleSubColumns = column.columns.filter(function (d) {
          return pivotBy.indexOf(d.id) > -1 ? false : _.getFirstDefined(d.show, true);
        });
        return _extends({}, column, {
          columns: visibleSubColumns
        });
      }
      return column;
    });

    visibleColumns = visibleColumns.filter(function (column) {
      return column.columns ? column.columns.length : pivotBy.indexOf(column.id) > -1 ? false : _.getFirstDefined(column.show, true);
    });

    // Find any custom pivot location
    var pivotIndex = visibleColumns.findIndex(function (col) {
      return col.pivot;
    });

    // Handle Pivot Columns
    if (pivotBy.length) {
      // Retrieve the pivot columns in the correct pivot order
      var pivotColumns = [];
      pivotBy.forEach(function (pivotID) {
        var found = allDecoratedColumns.find(function (d) {
          return d.id === pivotID;
        });
        if (found) {
          pivotColumns.push(found);
        }
      });

      var PivotParentColumn = pivotColumns.reduce(function (prev, current) {
        return prev && prev === current.parentColumn && current.parentColumn;
      }, pivotColumns[0].parentColumn);

      var PivotGroupHeader = hasHeaderGroups && (PivotParentColumn ? PivotParentColumn.Header : pivotColumns[0].PivotHeader || pivotColumns[0].Header);

      var pivotColumnGroup = {
        Header: PivotGroupHeader,
        columns: pivotColumns.map(function (col) {
          return _extends({}, _this4.props.pivotDefaults, col, {
            pivoted: true
          });
        })
      };

      // Place the pivotColumns back into the visibleColumns
      if (pivotIndex >= 0) {
        pivotColumnGroup = _extends({}, visibleColumns[pivotIndex], pivotColumnGroup);
        visibleColumns.splice(pivotIndex, 1, pivotColumnGroup);
      } else {
        visibleColumns.unshift(pivotColumnGroup);
      }
    }

    // Build Header Groups
    var headerGroups = [];
    var currentSpan = [];

    // A convenience function to add a header and reset the currentSpan
    var addHeader = function addHeader(columns, column) {
      headerGroups.push(_extends({}, _this4.props.column, column, {
        columns: columns
      }));
      currentSpan = [];
    };

    // Build flast list of allVisibleColumns and HeaderGroups
    visibleColumns.forEach(function (column) {
      if (column.columns) {
        allVisibleColumns = allVisibleColumns.concat(column.columns);
        if (currentSpan.length > 0) {
          addHeader(currentSpan);
        }
        addHeader(column.columns, column);
        return;
      }
      allVisibleColumns.push(column);
      currentSpan.push(column);
    });
    if (hasHeaderGroups && currentSpan.length > 0) {
      addHeader(currentSpan);
    }

    // Access the data
    var accessRow = function accessRow(d, i) {
      var _row;

      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var row = (_row = {}, _row[originalKey] = d, _row[indexKey] = i, _row[subRowsKey] = d[subRowsKey], _row[nestingLevelKey] = level, _row);
      allDecoratedColumns.forEach(function (column) {
        if (column.expander) return;
        row[column.id] = column.accessor(d);
      });
      if (row[subRowsKey]) {
        row[subRowsKey] = row[subRowsKey].map(function (d, i) {
          return accessRow(d, i, level + 1);
        });
      }
      return row;
    };
    var resolvedData = data.map(function (d, i) {
      return accessRow(d, i);
    });

    var aggregatingColumns = allVisibleColumns.filter(function (d) {
      return !d.expander && d.aggregate;
    });

    // If pivoting, recursively group the data
    var aggregate = function aggregate(rows) {
      var aggregationValues = {};
      aggregatingColumns.forEach(function (column) {
        var values = rows.map(function (d) {
          return d[column.id];
        });
        aggregationValues[column.id] = column.aggregate(values, rows);
      });
      return aggregationValues;
    };
    if (pivotBy.length) {
      var groupRecursively = function groupRecursively(rows, keys) {
        var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        // This is the last level, just return the rows
        if (i === keys.length) {
          return rows;
        }
        // Group the rows together for this level
        var groupedRows = Object.entries(_.groupBy(rows, keys[i])).map(function (_ref) {
          var _ref2;

          var key = _ref[0],
              value = _ref[1];
          return _ref2 = {}, _ref2[pivotIDKey] = keys[i], _ref2[pivotValKey] = key, _ref2[keys[i]] = key, _ref2[subRowsKey] = value, _ref2[nestingLevelKey] = i, _ref2[groupedByPivotKey] = true, _ref2;
        });
        // Recurse into the subRows
        groupedRows = groupedRows.map(function (rowGroup) {
          var _extends2;

          var subRows = groupRecursively(rowGroup[subRowsKey], keys, i + 1);
          return _extends({}, rowGroup, (_extends2 = {}, _extends2[subRowsKey] = subRows, _extends2[aggregatedKey] = true, _extends2), aggregate(subRows));
        });
        return groupedRows;
      };
      resolvedData = groupRecursively(resolvedData, pivotBy);
    }

    return _extends({}, newState, {
      resolvedData: resolvedData,
      allVisibleColumns: allVisibleColumns,
      headerGroups: headerGroups,
      allDecoratedColumns: allDecoratedColumns,
      hasHeaderGroups: hasHeaderGroups
    });
  };

  this.getSortedData = function (resolvedState) {
    var manual = resolvedState.manual,
        sorted = resolvedState.sorted,
        filtered = resolvedState.filtered,
        defaultFilterMethod = resolvedState.defaultFilterMethod,
        resolvedData = resolvedState.resolvedData,
        allVisibleColumns = resolvedState.allVisibleColumns,
        allDecoratedColumns = resolvedState.allDecoratedColumns;


    var sortMethodsByColumnID = {};

    allDecoratedColumns.filter(function (col) {
      return col.sortMethod;
    }).forEach(function (col) {
      sortMethodsByColumnID[col.id] = col.sortMethod;
    });

    // Resolve the data from either manual data or sorted data
    return {
      sortedData: manual ? resolvedData : _this4.sortData(_this4.filterData(resolvedData, filtered, defaultFilterMethod, allVisibleColumns), sorted, sortMethodsByColumnID)
    };
  };

  this.fireFetchData = function () {
    _this4.props.onFetchData(_this4.getResolvedState(), _this4);
  };

  this.getStateOrProp = function (key) {
    return _.getFirstDefined(_this4.state[key], _this4.props[key]);
  };

  this.filterData = function (data, filtered, defaultFilterMethod, allVisibleColumns) {
    var filteredData = data;
    if (filtered.length) {
      filteredData = filtered.reduce(function (filteredSoFar, nextFilter) {
        var column = allVisibleColumns.find(function (x) {
          return x.id === nextFilter.id;
        });

        // Don't filter hidden columns or columns that have had their filters disabled
        if (!column || column.filterable === false) {
          return filteredSoFar;
        }

        var filterMethod = column.filterMethod || defaultFilterMethod;

        // If 'filterAll' is set to true, pass the entire dataset to the filter method
        if (column.filterAll) {
          return filterMethod(nextFilter, filteredSoFar, column);
        }
        return filteredSoFar.filter(function (row) {
          return filterMethod(nextFilter, row, column);
        });
      }, filteredData);

      // Apply the filter to the subrows if we are pivoting, and then
      // filter any rows without subcolumns because it would be strange to show
      filteredData = filteredData.map(function (row) {
        var _extends3;

        if (!row[_this4.props.subRowsKey]) {
          return row;
        }
        return _extends({}, row, (_extends3 = {}, _extends3[_this4.props.subRowsKey] = _this4.filterData(row[_this4.props.subRowsKey], filtered, defaultFilterMethod, allVisibleColumns), _extends3));
      }).filter(function (row) {
        if (!row[_this4.props.subRowsKey]) {
          return true;
        }
        return row[_this4.props.subRowsKey].length > 0;
      });
    }

    return filteredData;
  };

  this.sortData = function (data, sorted) {
    var sortMethodsByColumnID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!sorted.length) {
      return data;
    }

    var sortedData = (_this4.props.orderByMethod || _.orderBy)(data, sorted.map(function (sort) {
      // Support custom sorting methods for each column
      if (sortMethodsByColumnID[sort.id]) {
        return function (a, b) {
          return sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc);
        };
      }
      return function (a, b) {
        return _this4.props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc);
      };
    }), sorted.map(function (d) {
      return !d.desc;
    }), _this4.props.indexKey);

    sortedData.forEach(function (row) {
      if (!row[_this4.props.subRowsKey]) {
        return;
      }
      row[_this4.props.subRowsKey] = _this4.sortData(row[_this4.props.subRowsKey], sorted, sortMethodsByColumnID);
    });

    return sortedData;
  };

  this.getMinRows = function () {
    return _.getFirstDefined(_this4.props.minRows, _this4.getStateOrProp('pageSize'));
  };

  this.onPageChange = function (page) {
    var _props = _this4.props,
        onPageChange = _props.onPageChange,
        collapseOnPageChange = _props.collapseOnPageChange;


    var newState = { page: page };
    if (collapseOnPageChange) {
      newState.expanded = {};
    }
    _this4.setStateWithData(newState, function () {
      return onPageChange && onPageChange(page);
    });
  };

  this.onPageSizeChange = function (newPageSize) {
    var onPageSizeChange = _this4.props.onPageSizeChange;

    var _getResolvedState = _this4.getResolvedState(),
        pageSize = _getResolvedState.pageSize,
        page = _getResolvedState.page;

    // Normalize the page to display


    var currentRow = pageSize * page;
    var newPage = Math.floor(currentRow / newPageSize);

    _this4.setStateWithData({
      pageSize: newPageSize,
      page: newPage
    }, function () {
      return onPageSizeChange && onPageSizeChange(newPageSize, newPage);
    });
  };

  this.sortColumn = function (column, additive) {
    var _getResolvedState2 = _this4.getResolvedState(),
        sorted = _getResolvedState2.sorted,
        skipNextSort = _getResolvedState2.skipNextSort,
        defaultSortDesc = _getResolvedState2.defaultSortDesc;

    var firstSortDirection = Object.prototype.hasOwnProperty.call(column, 'defaultSortDesc') ? column.defaultSortDesc : defaultSortDesc;
    var secondSortDirection = !firstSortDirection;

    // we can't stop event propagation from the column resize move handlers
    // attached to the document because of react's synthetic events
    // so we have to prevent the sort function from actually sorting
    // if we click on the column resize element within a header.
    if (skipNextSort) {
      _this4.setStateWithData({
        skipNextSort: false
      });
      return;
    }

    var onSortedChange = _this4.props.onSortedChange;


    var newSorted = _.clone(sorted || []).map(function (d) {
      d.desc = _.isSortingDesc(d);
      return d;
    });
    if (!_.isArray(column)) {
      // Single-Sort
      var existingIndex = newSorted.findIndex(function (d) {
        return d.id === column.id;
      });
      if (existingIndex > -1) {
        var existing = newSorted[existingIndex];
        if (existing.desc === secondSortDirection) {
          if (additive) {
            newSorted.splice(existingIndex, 1);
          } else {
            existing.desc = firstSortDirection;
            newSorted = [existing];
          }
        } else {
          existing.desc = secondSortDirection;
          if (!additive) {
            newSorted = [existing];
          }
        }
      } else if (additive) {
        newSorted.push({
          id: column.id,
          desc: firstSortDirection
        });
      } else {
        newSorted = [{
          id: column.id,
          desc: firstSortDirection
        }];
      }
    } else {
      // Multi-Sort
      var _existingIndex = newSorted.findIndex(function (d) {
        return d.id === column[0].id;
      });
      // Existing Sorted Column
      if (_existingIndex > -1) {
        var _existing = newSorted[_existingIndex];
        if (_existing.desc === secondSortDirection) {
          if (additive) {
            newSorted.splice(_existingIndex, column.length);
          } else {
            column.forEach(function (d, i) {
              newSorted[_existingIndex + i].desc = firstSortDirection;
            });
          }
        } else {
          column.forEach(function (d, i) {
            newSorted[_existingIndex + i].desc = secondSortDirection;
          });
        }
        if (!additive) {
          newSorted = newSorted.slice(_existingIndex, column.length);
        }
        // New Sort Column
      } else if (additive) {
        newSorted = newSorted.concat(column.map(function (d) {
          return {
            id: d.id,
            desc: firstSortDirection
          };
        }));
      } else {
        newSorted = column.map(function (d) {
          return {
            id: d.id,
            desc: firstSortDirection
          };
        });
      }
    }

    _this4.setStateWithData({
      page: !sorted.length && newSorted.length || !additive ? 0 : _this4.state.page,
      sorted: newSorted
    }, function () {
      return onSortedChange && onSortedChange(newSorted, column, additive);
    });
  };

  this.filterColumn = function (column, value) {
    var _getResolvedState3 = _this4.getResolvedState(),
        filtered = _getResolvedState3.filtered;

    var onFilteredChange = _this4.props.onFilteredChange;

    // Remove old filter first if it exists

    var newFiltering = (filtered || []).filter(function (x) {
      return x.id !== column.id;
    });

    if (value !== '') {
      newFiltering.push({
        id: column.id,
        value: value
      });
    }

    _this4.setStateWithData({
      filtered: newFiltering
    }, function () {
      return onFilteredChange && onFilteredChange(newFiltering, column, value);
    });
  };

  this.resizeColumnStart = function (event, column, isTouch) {
    event.stopPropagation();
    var parentWidth = event.target.parentElement.getBoundingClientRect().width;

    var pageX = void 0;
    if (isTouch) {
      pageX = event.changedTouches[0].pageX;
    } else {
      pageX = event.pageX;
    }

    _this4.trapEvents = true;
    _this4.setStateWithData({
      currentlyResizing: {
        id: column.id,
        startX: pageX,
        parentWidth: parentWidth
      }
    }, function () {
      if (isTouch) {
        document.addEventListener('touchmove', _this4.resizeColumnMoving);
        document.addEventListener('touchcancel', _this4.resizeColumnEnd);
        document.addEventListener('touchend', _this4.resizeColumnEnd);
      } else {
        document.addEventListener('mousemove', _this4.resizeColumnMoving);
        document.addEventListener('mouseup', _this4.resizeColumnEnd);
        document.addEventListener('mouseleave', _this4.resizeColumnEnd);
      }
    });
  };

  this.resizeColumnMoving = function (event) {
    event.stopPropagation();
    var onResizedChange = _this4.props.onResizedChange;

    var _getResolvedState4 = _this4.getResolvedState(),
        resized = _getResolvedState4.resized,
        currentlyResizing = _getResolvedState4.currentlyResizing;

    // Delete old value


    var newResized = resized.filter(function (x) {
      return x.id !== currentlyResizing.id;
    });

    var pageX = void 0;

    if (event.type === 'touchmove') {
      pageX = event.changedTouches[0].pageX;
    } else if (event.type === 'mousemove') {
      pageX = event.pageX;
    }

    // Set the min size to 10 to account for margin and border or else the
    // group headers don't line up correctly
    var newWidth = Math.max(currentlyResizing.parentWidth + pageX - currentlyResizing.startX, 11);

    newResized.push({
      id: currentlyResizing.id,
      value: newWidth
    });

    _this4.setStateWithData({
      resized: newResized
    }, function () {
      return onResizedChange && onResizedChange(newResized, event);
    });
  };

  this.resizeColumnEnd = function (event) {
    event.stopPropagation();
    var isTouch = event.type === 'touchend' || event.type === 'touchcancel';

    if (isTouch) {
      document.removeEventListener('touchmove', _this4.resizeColumnMoving);
      document.removeEventListener('touchcancel', _this4.resizeColumnEnd);
      document.removeEventListener('touchend', _this4.resizeColumnEnd);
    }

    // If its a touch event clear the mouse one's as well because sometimes
    // the mouseDown event gets called as well, but the mouseUp event doesn't
    document.removeEventListener('mousemove', _this4.resizeColumnMoving);
    document.removeEventListener('mouseup', _this4.resizeColumnEnd);
    document.removeEventListener('mouseleave', _this4.resizeColumnEnd);

    // The touch events don't propagate up to the sorting's onMouseDown event so
    // no need to prevent it from happening or else the first click after a touch
    // event resize will not sort the column.
    if (!isTouch) {
      _this4.setStateWithData({
        skipNextSort: true,
        currentlyResizing: false
      });
    }
  };
};

export default ReactTable;