var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Box, Button, Heading, Meter, Text } from 'grommet';
import { Close } from 'grommet-icons/icons/Close';
import { StatusGood } from 'grommet-icons/icons/StatusGood';
import { StatusWarning } from 'grommet-icons/icons/StatusWarning';
import { StatusCritical } from 'grommet-icons/icons/StatusCritical';
import { StatusUnknown } from 'grommet-icons/icons/StatusUnknown';
import { StatusInfo } from 'grommet-icons/icons/StatusInfo';
import { StatusDisabled } from 'grommet-icons/icons/StatusDisabled';
import { longDate } from '../../utils/moment';

var StatusIcons = {
  ok: StatusGood,
  warning: StatusWarning,
  error: StatusCritical,
  unknown: StatusUnknown,
  disabled: StatusDisabled,
  info: StatusInfo
};

var SIZE_LEVELS = {
  small: {
    level: 4,
    size: 'xsmall',
    meterSize: 'xsmall'
  },
  medium: {
    level: 3,
    size: 'small',
    meterSize: 'small'
  },
  large: {
    level: 1,
    size: 'medium',
    meterSize: 'large'
  }
};

var Notification = function (_Component) {
  _inherits(Notification, _Component);

  function Notification() {
    _classCallCheck(this, Notification);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  Notification.prototype.render = function render() {
    var _props = this.props,
        status = _props.status,
        message = _props.message,
        locale = _props.locale,
        closer = _props.closer,
        margin = _props.margin,
        reverse = _props.reverse,
        a11yTitle = _props.a11yTitle,
        background = _props.background,
        border = _props.border,
        timestamp = _props.timestamp,
        icon = _props.icon,
        strong = _props.strong,
        round = _props.round,
        pad = _props.pad,
        size = _props.size,
        state = _props.state,
        onClose = _props.onClose,
        percentComplete = _props.percentComplete,
        rest = _objectWithoutProperties(_props, ['status', 'message', 'locale', 'closer', 'margin', 'reverse', 'a11yTitle', 'background', 'border', 'timestamp', 'icon', 'strong', 'round', 'pad', 'size', 'state', 'onClose', 'percentComplete']);

    var sizeLevel = SIZE_LEVELS[size];
    var grommet = this.context.grommet;

    var closeBtn = void 0;
    if (onClose) {
      var closeIcon = closer || React.createElement(Close, { size: sizeLevel.size });
      closeBtn = React.createElement(
        Box,
        { pad: pad },
        React.createElement(
          Button,
          {
            a11yTitle: a11yTitle,
            onClick: onClose
          },
          closeIcon
        )
      );
    }
    var heading = message;
    if (strong) {
      heading = React.createElement(
        'strong',
        null,
        heading
      );
    }
    var statusIcon = void 0;
    if (icon) {
      var StatusIcon = StatusIcons[status];
      statusIcon = React.isValidElement(icon) ? icon : React.createElement(StatusIcon, { size: sizeLevel.size });
    }
    var progress = void 0;
    if (percentComplete || percentComplete === 0) {
      progress = React.createElement(
        Box,
        { direction: 'row', align: 'center', pad: { between: 'medium' }, style: { whiteSpace: 'nowrap' } },
        React.createElement(Meter, {
          size: sizeLevel.meterSize,
          thickness: 'small',
          values: [{
            label: percentComplete.toFixed(0),
            value: percentComplete,
            color: 'accent-1'
          }]
        }),
        React.createElement(
          Text,
          { size: 'small' },
          ' ' + percentComplete + ' %'
        )
      );
    }
    var timeStamp = void 0;
    if (timestamp) {
      timeStamp = longDate(timestamp, locale);
    }
    var first = void 0;
    var second = void 0;
    if (reverse) {
      first = heading;
      second = statusIcon;
    } else {
      first = statusIcon;
      second = heading;
    }
    var content = React.createElement(
      Box,
      { flex: 'grow', pad: pad },
      React.createElement(
        Heading,
        { level: sizeLevel.level, margin: margin, style: { maxWidth: '100%' } },
        React.createElement(
          Box,
          { direction: 'row', align: 'center', gap: 'small' },
          first,
          second
        )
      ),
      React.createElement(
        Text,
        { size: sizeLevel.size },
        state
      ),
      React.createElement(
        Text,
        { size: sizeLevel.size },
        timeStamp
      ),
      progress
    );
    if (reverse) {
      first = closeBtn;
      second = content;
    } else {
      first = content;
      second = closeBtn;
    }
    return React.createElement(
      Box,
      _extends({
        direction: 'row',
        fill: 'horizontal',
        border: border,
        round: round,
        onClick: this.clickTag,
        role: 'checkbox',
        'aria-checked': true,
        background: background || 'status-' + status,
        reverse: reverse,
        grommet: grommet
      }, rest),
      first,
      second
    );
  };

  return Notification;
}(Component);

Notification.contextTypes = {
  grommet: PropTypes.object
};
Notification.defaultProps = {
  status: 'info',
  size: 'medium',
  message: 'Notification...',
  icon: true,
  animation: 'fadeIn',
  closer: undefined,
  pad: 'small',
  margin: 'small',
  locale: 'en-us'
};


var NotificationDoc = void 0;
if (process.env.NODE_ENV !== 'production') {
  NotificationDoc = require('./doc').default(Notification); // eslint-disable-line global-require
}

var NotificationWrapper = NotificationDoc || Notification;

export { NotificationWrapper as Notification };