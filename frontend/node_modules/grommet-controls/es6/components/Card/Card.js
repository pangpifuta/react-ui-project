var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import { ThemeContext } from 'styled-components';
import { Box, Heading } from 'grommet';
import { StyledCard } from './StyledCard';

var Card = function (_Component) {
  _inherits(Card, _Component);

  function Card(props, context) {
    _classCallCheck(this, Card);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

    _this.toggleInnerContent = function (showInnner) {
      var _this$props = _this.props,
          backContent = _this$props.backContent,
          onFlip = _this$props.onFlip;

      if (backContent) {
        var flipped = _this.state.flipped;

        if (flipped !== showInnner) {
          _this.setState({ flipped: showInnner }, function () {
            if (onFlip) {
              // timeout to allow event to propagate
              setTimeout(function () {
                onFlip(showInnner);
              }, 0);
            }
          });
        }
      }
    };

    _this.onHover = function (hover) {
      _this.toggleInnerContent(hover);
    };

    _this.state = { flipped: !!props.flipped };
    return _this;
  }

  Card.prototype.componentWillReceiveProps = function componentWillReceiveProps(_ref) {
    var nextFlipped = _ref.flipped;
    var flipped = this.state.flipped;

    if (nextFlipped !== undefined && nextFlipped !== flipped) {
      this.toggleInnerContent(nextFlipped);
    }
  };

  Card.prototype.render = function render() {
    var _props = this.props,
        align = _props.align,
        gap = _props.gap,
        children = _props.children,
        rest = _objectWithoutProperties(_props, ['align', 'gap', 'children']);

    return React.createElement(
      ThemeContext.Consumer,
      null,
      function (theme) {
        return React.createElement(
          StyledCard,
          _extends({
            theme: theme,
            align: align,
            gap: gap,
            overflow: 'hidden'
          }, rest),
          children
        );
      }
    );
  };

  return Card;
}(Component);

Card.defaultProps = {
  align: 'center',
  border: 'all',
  elevation: 'small',
  round: 'xsmall',
  flex: false,
  gap: 'small',
  backContent: undefined,
  flipped: false,
  fill: 'horizontal',
  flipOnHover: true,
  background: 'white',
  flipDuration: 0.3
};


var CardDoc = void 0;
if (process.env.NODE_ENV !== 'production') {
  CardDoc = require('./doc').default(Card); // eslint-disable-line global-require
}
var CardWrapper = CardDoc || Card;

CardWrapper.CardActions = function (_ref2) {
  var children = _ref2.children,
      _ref2$pad = _ref2.pad,
      pad = _ref2$pad === undefined ? 'small' : _ref2$pad,
      rest = _objectWithoutProperties(_ref2, ['children', 'pad']);

  return React.createElement(
    Box,
    _extends({ justifySelf: 'end', align: 'center', pad: pad, gap: 'small', border: 'top', flex: false, fill: 'horizontal', direction: 'row' }, rest),
    children
  );
};

CardWrapper.CardTitle = function (_ref3) {
  var children = _ref3.children,
      color = _ref3.color,
      textAlign = _ref3.textAlign,
      truncate = _ref3.truncate,
      _ref3$level = _ref3.level,
      level = _ref3$level === undefined ? 4 : _ref3$level,
      _ref3$pad = _ref3.pad,
      pad = _ref3$pad === undefined ? 'small' : _ref3$pad,
      _ref3$strong = _ref3.strong,
      strong = _ref3$strong === undefined ? false : _ref3$strong,
      responsive = _ref3.responsive,
      rest = _objectWithoutProperties(_ref3, ['children', 'color', 'textAlign', 'truncate', 'level', 'pad', 'strong', 'responsive']);

  return React.createElement(
    Box,
    _extends({ responsive: responsive, direction: 'row', fill: 'horizontal', pad: pad, border: 'bottom', gap: 'small', flex: false }, rest),
    typeof children !== 'string' ? children : React.createElement(
      Heading,
      {
        level: level,
        margin: 'none',
        color: color,
        textAlign: textAlign,
        truncate: truncate,
        responsive: responsive
      },
      strong ? React.createElement(
        'strong',
        null,
        children
      ) : children
    )
  );
};

CardWrapper.CardContent = function (_ref4) {
  var children = _ref4.children,
      _ref4$pad = _ref4.pad,
      pad = _ref4$pad === undefined ? 'small' : _ref4$pad,
      rest = _objectWithoutProperties(_ref4, ['children', 'pad']);

  return React.createElement(
    Box,
    _extends({ pad: pad, fill: true, flex: true }, rest),
    children
  );
};

// eslint-disable-next-line import/prefer-default-export
export { CardWrapper as Card };