'use strict';

exports.__esModule = true;
exports.withChartTheme = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _grommet = require('grommet');

var _colors = require('grommet/utils/colors');

var _object = require('grommet/utils/object');

var _colors2 = require('../../utils/colors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var normalizedColor = function normalizedColor(color, theme) {
  return (0, _colors2.colorForName)((0, _colors.normalizeColor)(color, theme), theme);
};

// eslint-disable-next-line import/prefer-default-export
var withChartTheme = function withChartTheme(WrappedComponent) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _ref$classOpacity = _ref.classOpacity,
      classOpacity = _ref$classOpacity === undefined ? 0.6 : _ref$classOpacity,
      _ref$defaultScales = _ref.defaultScales,
      defaultScales = _ref$defaultScales === undefined ? [{}] : _ref$defaultScales,
      other = _objectWithoutProperties(_ref, ['classOpacity', 'defaultScales']);

  return function (_ref2) {
    var options = _ref2.options,
        data = _ref2.data;
    return _react2.default.createElement(
      _grommet.ThemeContext.Consumer,
      null,
      function (theme) {
        var textColor = normalizedColor('text', theme);
        var axisColors = {
          ticks: {
            fontColor: textColor
          },
          gridLines: {
            color: normalizedColor('border', theme)
          },
          scaleLabel: {
            fontColor: textColor
          }
        };
        var defaultOptions = {
          maintainAspectRatio: false,
          title: {
            fontColor: textColor
          },
          legend: {
            labels: {
              fontColor: textColor
            }
          },
          scales: {}
        };
        var themedOptions = (0, _object.deepMerge)(defaultOptions, options);

        themedOptions.scales.xAxes = themedOptions.scales.xAxes || defaultScales;
        themedOptions.scales.yAxes = themedOptions.scales.yAxes || defaultScales;
        themedOptions.scales.xAxes = themedOptions.scales.xAxes.map(function (x) {
          return (0, _object.deepMerge)(axisColors, x);
        });
        themedOptions.scales.yAxes = themedOptions.scales.yAxes.map(function (y) {
          return (0, _object.deepMerge)(axisColors, y);
        });
        var datasets = void 0;
        if (data && Array.isArray(data.datasets)) {
          datasets = data.datasets.map(function (dataset, i) {
            var backgroundColor = dataset.backgroundColor,
                borderColor = dataset.borderColor,
                color = dataset.color,
                rest = _objectWithoutProperties(dataset, ['backgroundColor', 'borderColor', 'color']);

            var newOpts = void 0;
            var themeColors = function themeColors(index, itemOpacity) {
              var lineColor = borderColor || color || (0, _colors2.colorFromIndex)(index);
              var lineColors = Array.isArray(lineColor) ? lineColor.map(function (c) {
                return normalizedColor(c, theme);
              }) : normalizedColor(lineColor, theme);
              var fillColor = backgroundColor || lineColor;
              var opacity = itemOpacity || dataset.opacity || options && options.opacity || classOpacity;
              var fillColors = Array.isArray(fillColor) ? fillColor.map(function (c) {
                return (0, _colors.getRGBA)(normalizedColor(c, theme), opacity);
              }) : (0, _colors.getRGBA)(normalizedColor(fillColor, theme), opacity);
              return {
                backgroundColor: fillColors,
                borderColor: lineColors
              };
            };
            if (options && options.themedData && dataset.data) {
              newOpts = { backgroundColor: [], borderColor: [] };
              dataset.data.forEach(function (dataRow, rIndex) {
                var colors = themeColors(rIndex, dataRow.opacity);
                newOpts.backgroundColor.push(colors.backgroundColor);
                newOpts.borderColor.push(colors.borderColor);
              });
            } else {
              newOpts = themeColors(i);
            }
            return _extends({}, newOpts, other, rest);
          });
        }
        return _react2.default.createElement(WrappedComponent, {
          options: themedOptions,
          data: _extends({}, data, { datasets: datasets })
        });
      }
    );
  };
};
exports.withChartTheme = withChartTheme;